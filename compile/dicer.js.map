{
"version":3,
"file":"compile/dicer.js",
"lineCount":277,
"mappings":"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",
"sources":["node_modules/stream/index.js","node_modules/events/index.js","src/streamsearch/index.js","src/PartStream.js","src/HeaderParser.js","src/index.js","src/depack.js"],
"sourcesContent":["export default stream\nexport const {\n  Duplex,\n  PassThrough,\n  Readable,\n  Stream,\n  Transform,\n  Writable,\n} = stream","export default events\nexport const {\n  EventEmitter,\n} = events","/*\n  Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation\n  by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool\n*/\nimport { EventEmitter } from 'events'\n\nfunction jsmemcmp(buf1, pos1, buf2, pos2, num) {\n  for (var i = 0; i < num; ++i, ++pos1, ++pos2)\n    if (buf1[pos1] !== buf2[pos2])\n      return false\n  return true\n}\n\nexport default class SBMH extends EventEmitter {\n  constructor(needle) {\n    super()\n    if (typeof needle === 'string')\n      needle = new Buffer(needle)\n    var i, j, needle_len = needle.length\n\n    this.maxMatches = Infinity\n    this.matches = 0\n\n    this._occ = new Array(256)\n    this._lookbehind_size = 0\n    this._needle = needle\n    this._bufpos = 0\n\n    this._lookbehind = new Buffer(needle_len)\n\n    // Initialize occurrence table.\n    for (j = 0; j < 256; ++j)\n      this._occ[j] = needle_len\n\n    // Populate occurrence table with analysis of the needle,\n    // ignoring last letter.\n    if (needle_len >= 1) {\n      for (i = 0; i < needle_len - 1; ++i)\n        this._occ[needle[i]] = needle_len - 1 - i\n    }\n  }\n  reset() {\n    this._lookbehind_size = 0\n    this.matches = 0\n    this._bufpos = 0\n  }\n  push(chunk, pos = 0) {\n    var r, chlen\n    if (!Buffer.isBuffer(chunk))\n      chunk = new Buffer(chunk, 'binary')\n    chlen = chunk.length\n    this._bufpos = pos\n    while (r !== chlen && this.matches < this.maxMatches)\n      r = this._sbmh_feed(chunk)\n    return r\n  }\n  _sbmh_feed(data) {\n    var len = data.length, needle = this._needle, needle_len = needle.length\n\n    // Positive: points to a position in `data`\n    //           pos == 3 points to data[3]\n    // Negative: points to a position in the lookbehind buffer\n    //           pos == -2 points to lookbehind[lookbehind_size - 2]\n    var pos = -this._lookbehind_size,\n      last_needle_char = needle[needle_len - 1],\n      occ = this._occ,\n      lookbehind = this._lookbehind,\n      ch\n\n    if (pos < 0) {\n    // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool\n    // search with character lookup code that considers both the\n    // lookbehind buffer and the current round's haystack data.\n    //\n    // Loop until\n    //   there is a match.\n    // or until\n    //   we've moved past the position that requires the\n    //   lookbehind buffer. In this case we switch to the\n    //   optimized loop.\n    // or until\n    //   the character to look at lies outside the haystack.\n      while (pos < 0 && pos <= len - needle_len) {\n        ch = this._sbmh_lookup_char(data, pos + needle_len - 1)\n\n        if (ch === last_needle_char\n          && this._sbmh_memcmp(data, pos, needle_len - 1)) {\n          this._lookbehind_size = 0\n          ++this.matches\n          if (pos > -this._lookbehind_size)\n            this.emit('info', true, lookbehind, 0, this._lookbehind_size + pos)\n          else\n            this.emit('info', true)\n\n          return (this._bufpos = pos + needle_len)\n        } else\n          pos += occ[ch]\n      }\n\n      // No match.\n\n      if (pos < 0) {\n      // There's too few data for Boyer-Moore-Horspool to run,\n      // so let's use a different algorithm to skip as much as\n      // we can.\n      // Forward pos until\n      //   the trailing part of lookbehind + data\n      //   looks like the beginning of the needle\n      // or until\n      //   pos == 0\n        while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos))\n          pos++\n      }\n\n      if (pos >= 0) {\n      // Discard lookbehind buffer.\n        this.emit('info', false, lookbehind, 0, this._lookbehind_size)\n        this._lookbehind_size = 0\n      } else {\n      // Cut off part of the lookbehind buffer that has\n      // been processed and append the entire haystack\n      // into it.\n        var bytesToCutOff = this._lookbehind_size + pos\n\n        if (bytesToCutOff > 0) {\n        // The cut off data is guaranteed not to contain the needle.\n          this.emit('info', false, lookbehind, 0, bytesToCutOff)\n        }\n\n        lookbehind.copy(lookbehind, 0, bytesToCutOff,\n          this._lookbehind_size - bytesToCutOff)\n        this._lookbehind_size -= bytesToCutOff\n\n        data.copy(lookbehind, this._lookbehind_size)\n        this._lookbehind_size += len\n\n        this._bufpos = len\n        return len\n      }\n    }\n\n    if (pos >= 0)\n      pos += this._bufpos\n\n    // Lookbehind buffer is now empty. Perform Boyer-Moore-Horspool\n    // search with optimized character lookup code that only considers\n    // the current round's haystack data.\n    while (pos <= len - needle_len) {\n      ch = data[pos + needle_len - 1]\n\n      if (ch === last_needle_char\n        && data[pos] === needle[0]\n        && jsmemcmp(needle, 0, data, pos, needle_len - 1)) {\n        ++this.matches\n        if (pos > 0)\n          this.emit('info', true, data, this._bufpos, pos)\n        else\n          this.emit('info', true)\n\n        return (this._bufpos = pos + needle_len)\n      } else\n        pos += occ[ch]\n    }\n\n    // There was no match. If there's trailing haystack data that we cannot\n    // match yet using the Boyer-Moore-Horspool algorithm (because the trailing\n    // data is less than the needle size) then match using a modified\n    // algorithm that starts matching from the beginning instead of the end.\n    // Whatever trailing data is left after running this algorithm is added to\n    // the lookbehind buffer.\n    if (pos < len) {\n      while (pos < len && (data[pos] !== needle[0]\n                         || !jsmemcmp(data, pos, needle, 0, len - pos))) {\n        ++pos\n      }\n      if (pos < len) {\n        data.copy(lookbehind, 0, pos, pos + (len - pos))\n        this._lookbehind_size = len - pos\n      }\n    }\n\n    // Everything until pos is guaranteed not to contain needle data.\n    if (pos > 0)\n      this.emit('info', false, data, this._bufpos, pos < len ? pos : len)\n\n    this._bufpos = len\n    return len\n  }\n  _sbmh_lookup_char(data, pos) {\n    if (pos < 0) {\n      /** @suppress {checkTypes} */\n      const res = this._lookbehind[this._lookbehind_size + pos]\n      return res\n    }\n    else\n      return data[pos]\n  }\n  _sbmh_memcmp(data, pos, len) {\n    var i = 0\n\n    while (i < len) {\n      if (this._sbmh_lookup_char(data, pos + i) === this._needle[i])\n        ++i\n      else\n        return false\n    }\n    return true\n  }\n}\n\n/**\n * @license MIT streamsearch by Brian White\n * https://github.com/mscdex/streamsearch\n */","import { Readable } from 'stream'\n\nexport default class PartStream extends Readable {\n  constructor(opts) {\n    super(opts)\n  }\n  _read() {}\n}","import { EventEmitter } from 'events'\nimport StreamSearch from './streamsearch'\n\nconst B_DCRLF = Buffer.from('\\r\\n\\r\\n')\nconst RE_CRLF = /\\r\\n/g\nconst RE_HDR = /^([^:]+):[ \\t]?([\\x00-\\xFF]+)?$/ // eslint-disable-line\nconst MAX_HEADER_PAIRS = 2000 // from node's http.js\nconst MAX_HEADER_SIZE = 80 * 1024 // from node's http_parser\n\nexport default class HeaderParser extends EventEmitter {\n  /**\n   * @param {_idio.DicerConfig} [cfg] Options for the program.\n   * @param {string} [cfg.boundary] This is the boundary used to detect the beginning of a new part.\n   * @param {boolean} [cfg.headerFirst=false] If true, preamble header parsing will be performed first. Default `false`.\n   * @param {boolean} [cfg.partHwm] High watermark for parsing parts.\n   * @param {number} [cfg.maxHeaderPairs=2000] The maximum number of header key=>value pairs to parse. Default `2000`.\n   */\n  constructor(cfg = {}) {\n    super()\n    const { maxHeaderPairs = MAX_HEADER_PAIRS } = cfg\n\n    // var self = this\n    this.nread = 0\n    this.maxed = false\n    this.npairs = 0\n    this.maxHeaderPairs = maxHeaderPairs\n    this.buffer = ''\n    this.header = {}\n    this.finished = false\n    this.ss = new StreamSearch(B_DCRLF)\n    this.ss.on('info', (isMatch, data, start, end) => {\n      if (data && !this.maxed) {\n        if (this.nread + (end - start) > MAX_HEADER_SIZE) {\n          end = (MAX_HEADER_SIZE - this.nread)\n          this.nread = MAX_HEADER_SIZE\n        } else\n          this.nread += (end - start)\n\n        if (this.nread === MAX_HEADER_SIZE)\n          this.maxed = true\n\n        this.buffer += data.toString('binary', start, end)\n      }\n      if (isMatch)\n        this._finish()\n    })\n  }\n  push(data) {\n    var r = this.ss.push(data)\n    if (this.finished)\n      return r\n  }\n  reset() {\n    this.finished = false\n    this.buffer = ''\n    this.header = {}\n    this.ss.reset()\n  }\n  _finish() {\n    if (this.buffer)\n      this._parseHeader()\n    this.ss.matches = this.ss.maxMatches\n    var header = this.header\n    this.header = {}\n    this.buffer = ''\n    this.finished = true\n    this.nread = this.npairs = 0\n    this.maxed = false\n    this.emit('header', header)\n  }\n  _parseHeader() {\n    if (this.npairs === this.maxHeaderPairs)\n      return\n\n    var lines = this.buffer.split(RE_CRLF), len = lines.length, m, h,\n      modded = false\n\n    for (let i = 0; i < len; ++i) {\n      if (lines[i].length === 0)\n        continue\n      if (lines[i][0] == '\\t' || lines[i][0] == ' ') {\n        // folded header content\n        // RFC2822 says to just remove the CRLF and not the whitespace following\n        // it, so we follow the RFC and include the leading whitespace ...\n        this.header[h][this.header[h].length - 1] += lines[i]\n      } else {\n        m = RE_HDR.exec(lines[i])\n        if (m) {\n          h = m[1].toLowerCase()\n          if (m[2]) {\n            if (this.header[h] === undefined)\n              this.header[h] = [m[2]]\n            else\n              this.header[h].push(m[2])\n          } else\n            this.header[h] = ['']\n          if (++this.npairs === this.maxHeaderPairs)\n            break\n        } else {\n          this.buffer = lines[i]\n          modded = true\n          break\n        }\n      }\n    }\n    if (!modded)\n      this.buffer = ''\n  }\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../types').DicerConfig} _idio.DicerConfig\n */","import { Writable } from 'stream'\nimport StreamSearch from './streamsearch'\nimport PartStream from './PartStream'\nimport HeaderParser from './HeaderParser'\n\nconst DASH = 45\nconst B_ONEDASH = Buffer.from('-')\nconst B_CRLF = Buffer.from('\\r\\n')\nconst EMPTY_FN = () => {}\n\n/**\n * @implements {_idio.Dicer}\n */\nexport default class Dicer extends Writable {\n  /**\n   * @param {!_idio.DicerConfig} [cfg] Options for the program.\n   * @param {string} [cfg.boundary] This is the boundary used to detect the beginning of a new part.\n   * @param {boolean} [cfg.headerFirst=false] If true, preamble header parsing will be performed first. Default `false`.\n   * @param {boolean} [cfg.partHwm] High watermark for parsing parts.\n   * @param {number} [cfg.maxHeaderPairs=2000] The maximum number of header key=>value pairs to parse. Default `2000`.\n   */\n  constructor(cfg) {\n    super(/** @type {!stream.WritableOptions|undefined} */ (cfg))\n    if (!cfg || (!cfg.headerFirst && typeof cfg.boundary != 'string'))\n      throw new TypeError('Boundary required')\n\n    if (typeof cfg.boundary == 'string')\n      this.setBoundary(cfg.boundary)\n    else\n      /** @type {!StreamSearch|undefined} */\n      this._bparser = undefined\n\n    this._headerFirst = cfg.headerFirst\n\n    this._dashes = 0\n    this._parts = 0\n    this._finished = false\n    this._realFinish = false\n    this._isPreamble = true\n    this._justMatched = false\n    this._firstWrite = true\n    this._inHeader = true\n    /**\n     * @type {!PartStream|undefined}\n     */\n    this._part = undefined\n    this._cb = undefined\n    this._ignoreData = false\n    this._partOpts = /** @type {!stream.ReadableOptions} */ (typeof cfg.partHwm == 'number'\n      ? { highWaterMark: cfg.partHwm }\n      : {})\n    this._pause = false\n\n    this._hparser = new HeaderParser(cfg)\n    this._hparser.on('header', (header) => {\n      this._inHeader = false\n      this._part.emit('header', header)\n    })\n  }\n  emit(ev) {\n    if (ev == 'finish' && !this._realFinish) {\n      if (!this._finished) {\n        process.nextTick(() => {\n          this.emit('error', new Error('Unexpected end of multipart data'))\n          if (this._part && !this._ignoreData) {\n            var type = (this._isPreamble ? 'Preamble' : 'Part')\n            this._part.emit('error', new Error(type + ' terminated early due to unexpected end of multipart data'))\n            this._part.push(null)\n            process.nextTick(() => {\n              this._realFinish = true\n              this.emit('finish')\n              this._realFinish = false\n            })\n            return\n          }\n          this._realFinish = true\n          this.emit('finish')\n          this._realFinish = false\n        })\n      }\n    } else\n      Writable.prototype.emit.apply(this, arguments)\n    return false\n  }\n  _write(data, encoding, cb) {\n    // ignore unexpected data (e.g. extra trailer data after finished)\n    if (!this._hparser && !this._bparser)\n      return cb()\n\n    if (this._headerFirst && this._isPreamble) {\n      if (!this._part) {\n        this._part = new PartStream(this._partOpts)\n        if (this._events['preamble'])\n          this.emit('preamble', this._part)\n        else\n          this._ignore()\n      }\n      const r = this._hparser.push(data)\n      if (!this._inHeader && r !== undefined && r < data.length)\n        data = data.slice(r)\n      else\n        return cb()\n    }\n\n    // allows for \"easier\" testing\n    if (this._firstWrite) {\n      // this.start = +new Date\n      this._bparser.push(B_CRLF)\n      this._firstWrite = false\n    }\n\n    // this.start = +new Date\n    this._bparser.push(data)\n\n    if (this._pause)\n      this._cb = cb\n    else\n      cb()\n  }\n  reset() {\n    this._part = undefined\n    this._bparser = undefined\n    this._hparser = undefined\n  }\n  setBoundary(boundary) {\n    this._bparser = new StreamSearch('\\r\\n--' + boundary)\n    this._bparser.on('info', (isMatch, data, start, end) => {\n      this._oninfo(isMatch, data, start, end)\n      // const duration = +new Date - this.start\n      // console.log('found in %sms', duration)\n    })\n  }\n  _ignore() {\n    if (this._part && !this._ignoreData) {\n      this._ignoreData = true\n      this._part.on('error', EMPTY_FN)\n      // we must perform some kind of read on the stream even though we are\n      // ignoring the data, otherwise node's Readable stream will not emit 'end'\n      // after pushing null to the stream\n      this._part.resume()\n    }\n  }\n  _oninfo(isMatch, data, start, end) {\n    var buf, i = 0, r, ev, shouldWriteMore = true\n\n    if (!this._part && this._justMatched && data) {\n      while (this._dashes < 2 && (start + i) < end) {\n        if (data[start + i] === DASH) {\n          ++i\n          ++this._dashes\n        } else {\n          if (this._dashes)\n            buf = B_ONEDASH\n          this._dashes = 0\n          break\n        }\n      }\n      if (this._dashes === 2) {\n        if ((start + i) < end && this._events.trailer)\n          this.emit('trailer', data.slice(start + i, end))\n        this.reset()\n        this._finished = true\n        // no more parts will be added\n        if (this._parts === 0) {\n          this._realFinish = true\n          this.emit('finish')\n          this._realFinish = false\n        }\n      }\n      if (this._dashes)\n        return\n    }\n    if (this._justMatched)\n      this._justMatched = false\n    if (!this._part) {\n      this._part = new PartStream(this._partOpts)\n      this._part._read = () => {\n        this._unpause()\n      }\n      ev = this._isPreamble ? 'preamble' : 'part'\n      if (this._events[ev])\n        this.emit(ev, this._part)\n      else\n        this._ignore()\n      if (!this._isPreamble)\n        this._inHeader = true\n    }\n    if (data && start < end && !this._ignoreData) {\n      if (this._isPreamble || !this._inHeader) {\n        if (buf)\n          shouldWriteMore = this._part.push(buf)\n        shouldWriteMore = this._part.push(data.slice(start, end))\n        if (!shouldWriteMore)\n          this._pause = true\n      } else if (!this._isPreamble && this._inHeader) {\n        if (buf)\n          this._hparser.push(buf)\n        r = this._hparser.push(data.slice(start, end))\n        if (!this._inHeader && r !== undefined && r < end)\n          this._oninfo(false, data, start + r, end)\n      }\n    }\n    if (isMatch) {\n      this._hparser.reset()\n      if (this._isPreamble)\n        this._isPreamble = false\n      else {\n        ++this._parts\n        this._part.on('end', () => {\n          if (--this._parts === 0) {\n            if (this._finished) {\n              this._realFinish = true\n              this.emit('finish')\n              this._realFinish = false\n            } else {\n              this._unpause()\n            }\n          }\n        })\n      }\n      this._part.push(null)\n      this._part = undefined\n      this._ignoreData = false\n      this._justMatched = true\n      this._dashes = 0\n    }\n  }\n  _unpause() {\n    if (!this._pause) return\n\n    this._pause = false\n    if (this._cb) {\n      const cb = this._cb\n      this._cb = undefined\n      cb()\n    }\n  }\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../types').DicerConfig} _idio.DicerConfig\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').ReadableOptions} stream.ReadableOptions\n */\n\n/**\n * @license MIT dicer by Brian White\n * https://github.com/mscdex/dicer\n */","import '../types/externs'\nimport Dicer from './'\n\nmodule.exports = Dicer"],
"names":["Readable","stream","Writable","EventEmitter","events","jsmemcmp","buf1","pos1","buf2","pos2","num","i","_sbmh_feed","data","len","length","needle","_needle","needle_len","pos","_lookbehind_size","last_needle_char","occ","_occ","lookbehind","_lookbehind","_sbmh_lookup_char","res","ch","_sbmh_memcmp","matches","emit","_bufpos","bytesToCutOff","copy","SBMH","Buffer","maxMatches","Infinity","Array","j","chunk","isBuffer","chlen","r","PartStream","opts","B_DCRLF","from","RE_CRLF","RE_HDR","reset","finished","buffer","header","ss","HeaderParser","cfg","maxHeaderPairs","MAX_HEADER_PAIRS","nread","maxed","npairs","StreamSearch","on","isMatch","start","end","MAX_HEADER_SIZE","toString","_finish","lines","split","modded","h","m","exec","toLowerCase","undefined","push","B_ONEDASH","B_CRLF","EMPTY_FN","_part","_bparser","_hparser","_oninfo","buf","shouldWriteMore","_justMatched","_dashes","DASH","_events","trailer","slice","_finished","_parts","_realFinish","_partOpts","_read","this._part._read","_unpause","ev","_isPreamble","_ignore","_inHeader","_ignoreData","_pause","_cb","cb","Dicer","headerFirst","boundary","TypeError","setBoundary","_headerFirst","_firstWrite","partHwm","highWaterMark","prototype","apply","arguments","process","nextTick","Error","type","encoding","resume","module","exports"]
}
